#### 前言

参考文章：https://www.zhihu.com/question/19732473/answer/14413599		    					 https://leetcode-cn.com/circle/discuss/uHGOZo/

在高性能的 IO 体系设计中，BIO、NIO、AIO 的概念，常常会让我们感到困惑不解。常见的几个问题：

- AIO、BIO、NIO 的概念
- AIO、BIO、NIO 的适用场景
- 同步/异步、阻塞/非阻塞的区别
- NIO 如何实现多路复用功能
- NIO 的核心概念、应用和框架等

#### 1. IO模型主要分类

- 同步 IO「synchronous」
- 异步 IO「asynchronous」
- 阻塞 IO「blocking」
- 非阻塞 IO「non-blocking」
- 同步阻塞「blocking-IO」，简称：BIO
- 同步非阻塞「non-blocking-IO」，简称：NIO
- 异步非阻塞「async-non- blocking-IO」，简称：AIO

![image-20210609190310107](/Users/kevintttccc/Library/Application Support/typora-user-images/image-20210609190310107.png)

##### 1.1 同步和异步的区别

​	从分布式系统角度的回答：`同步` 和 `异步` 关注的是「消息通信机制」。

​	所谓「同步」，就是发出一个「调用」时，在没有得到结果之前，该「调用」就不返回，但是一旦调用返回，就得到「返回值」了。换句话说，就是有「调用者」主动等待这个「调用」的结果。

​	而「异步」则是相反的，「调用」发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个「异步」请求发出之后，「调用者」不会立刻得到结果。而是在「调用」发出之后，「被调用者」通过状态、通知来通知「调用者」，或者通过「回调函数」处理这个调用。

##### 1.2 阻塞和非阻塞的区别

​	从分布式系统角度的回答：`阻塞`  和 `非阻塞` 关注的是「程序在等待调用结果（消息、返回值）」时的状态，

​	「阻塞」是指调用结果返回之前，当前线程会被「挂起」，「调用线程」只有在得到结果之后才返回。

​	「非阻塞调用」是指在「不能立刻得到」结果之前，该调用不会阻塞当前线程。

【扩展】

​		JavaNIO是非阻塞式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程会去执行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。因此NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。

#### 2. AIO、BIO、NIO 的区别

##### 2.1 BIO「同步阻塞 I/O 模型」

​	数据的「读取/写入」必须阻塞在一个线程内等待其完成。

##### 2.2 NIO 「同步非阻塞 I/O 模型」

​	同时支持阻塞于非阻塞模式，但这里只说明「同步非阻塞 I/O 模型」，NIO 的做法是一个线程不断轮训每个请求的状态，看看状态是否变更，然后进行下一步操作

##### 2.3 AIO 「异步非阻塞 I/O 模型」

​	「异步非阻塞」和「同步非阻塞」的区别在哪里？异步非阻塞无需一个线程去轮训所有「I/O」操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处。

##### 2.4 AIO、BIO、NIO 适用场景

- AIO：适用于连接数多，且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂
- BIO：适用于连接数较少，且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中
- NIO：适用于连接数较多，且连接比较短（轻操作）的架构，比如聊天服务器、Kafka 就是用这个模型，并发局限于应用中，编程比较复杂

#### 3. NIO 的 3 个核心概念

参考文档：https://tech.meituan.com/2016/11/04/nio.html

- Channel：通道
- Buffer：缓冲区
- Selector：多路复用器

##### 3.1 Channel 

​	Channel 是一个通道，可以通过它「读取/写入」数据，且是「全双工模式」的，可以用于「读」、「写」或者「读写」同时操作。

​	Channel 的四种实现：

- FileChannel ：从文件「读取」数据
- DatagramChannel：从 UDP 网络中「读取/写入」数据
- SocketChannel：从 TCP 网络中「读取/写入」数据
- ServerSocketChannel：允许监听来自 TCP 的连接，就像服务器一样。每一个连接都会有一个 SocketChannel 产生。

##### 3.2 Buffer

​	Buffer 是一个「对象」。它包含一些要「写入/读取」的数据。在面向「流式 I/O」中，可以将数据「写入/读取」到 `Stream` 对象中。

​	在 NIO 中，所有的数据都是用「缓冲区处理」，所以 NIO 是面向「缓冲区」的。

​	`缓冲区` 实质是一个「数组」，通常它是一个「字节数据 ByteBuffer」，也可以使用其他类的数据。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的「结构化访问」及「维护读写位置 limit」等信息。

​	最常用的缓冲区是「ByteBuffer」，一个「ByteBuffer」提供了一组功能用于操作「Byte 数组」，除了 ByteBuffer，还有其他的一些缓冲区，事实上，每一种 Java 基本类型（除了 Boolean）都对应一种缓冲区。

##### 3.3 Selector 

​	Selector `选择器` 是一个可以用于监视多个 Channel 的「对象」，如数据到达，连接打开等。因此。单线程可以监视多个通道中的数据。实现一个线程管理多个 Channel，节省线程之前切换上下文的资源消耗。

​	要使用 Selector 的话，我们必须把 Channel 注册到 Selector 上，然后就可以调用 Selector 的「select()」方法。这个方法会进入阻塞，直到有一个channel的状态符合条件。当条件返回后，线程可以处理这些事件。